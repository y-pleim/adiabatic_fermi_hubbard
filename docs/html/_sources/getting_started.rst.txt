Getting Started
===============

This page details how to get started with adiabatic_fermi_hubbard.

Installation
------------

This package is designed for Python 3.8-3.12, provided the following packages are installed in the environment:

* numpy
* qiskit 0.46.1
* qiskit-aer
* qiskit-nature
* qiskit-algorithms
* matplotlib (optional)

To install adiabatic_fermi_hubbard in an environment with the above dependencies installed, run the following
commands:

::

    git clone git@github.com:y-pleim/adiabatic_fermi_hubbard.git
    cd adiabatic_fermi_hubbard
    pip install -e .

Background
----------
Fermi-Hubbard Model
'''''''''''''''''''
This package simulates the ground state of the Fermi-Hubbard model, which describes the behavior of electrons (fermions)
on a lattice. The Hamiltonian is given by:

.. math:: H = -t \sum_{<i,j>,\sigma}(a_{i\sigma}^\dagger a_{j\sigma} + h.c.) + U\sum_{i} n_{i\uparrow}n_{i\downarrow}

where 

* :math:`\sigma \in \{ \uparrow, \downarrow \}` is the electron spin
* :math:`a_{i\sigma} (a_{i\sigma}^\dagger)` is the annihilation/creation operator corresponding to site :math:`i` and spin :math:`sigma`
* :math:`n_{i\sigma} = a_{i\sigma}^\dagger a_{i\sigma}` is the number operator corresponding to site :math:`i`
* :math:`<i, j>` denotes neighboring lattice sites
* :math:`t, ~U` are energy scales

The first term is the "hopping" term which describes how electrons move from site to site (e.g., for adjacent sites :math:`i, j`, an electron hopping from
:math:`i` to :math:`j` can be described by the product of an annihilation operator on site :math:`i` and creation operator on site :math:`j`). The strength of this
term is controlled by the parameter :math:`t`. The second term describes an interaction between two electrons on the same site, with strength :math:`U`. 
Depending on the relative strengths of :math:`t, U`, the above model captures superconducting, antiferromagnetic (and ferromagnetic), and insulating phases. 
It has been applied to explain phenomena in materials whose properties depend on correlations between electrons, including high-temperature cuprate superconductors **[1]**.

The above Hamiltonian can be modified to include a chemical potential term with strength :math:`\mu` to control the number of electrons in the lattice **[2]**:

.. math:: H = -t \sum_{<i,j>,\sigma}(a_{i\sigma}^\dagger a_{j\sigma} + h.c.) + U\sum_{i} n_{i\uparrow}n_{i\downarrow} + \mu \sum_{i,\sigma} n_{i\sigma}


Quantum Computing and the Fermi-Hubbard Model
'''''''''''''''''''''''''''''''''''''''''''''
The Fermi-Hubbard model has an analytical solution for 1D lattices; however, a more physically relevant case for materials is the 2D case, which cannot
be solved analytically and must be simulated. Classical simulation approaches have been effective in describing much of the phenomena; however, these techniques 
have limitations **[3]**. Quantum Monte Carlo (QMC) simulations are successful in describing many-electron lattices, provided the Boltzmann factors involved do not
become negative, which can happen in fermionic systems. For :math:`U > 0`, QMC simulations do not converge unless the lattice is "half-filled" due to this sign problem
**[4]**. "Half-filling" refers to the situation in which the number of lattice sites equals the number of electrons **[5]**. Exact diagonalization techniques, which utilize
symmetries to reduce the problem to a smaller Hilbert space, are effective for small lattice sizes **[6]**, **[7]**, **[8]**.

Due to the limitations of classical simulations, there has been significant interest for using quantum computers to simulate the Fermi-Hubbard model. These efforts
range from quantum emulation, in which evolution under the Hamiltonian is implemented on a representative qubit system (e.g., atomic lattices) **[3]**, to quantum algorithms
on spin qubits (e.g., variational quantum eigensolvers on superconducting qubits) **[9]**. Another approach to quantum simulation is adiabatic state preparation.

Adiabatic State Preparation
'''''''''''''''''''''''''''
A general approach to finding the ground state of a "difficult" Hamiltonian :math:`H_{final}` is to initialize a qubit system in the ground state of a known Hamiltonian 
:math:`H_{initial}` and evolve the system using evolution operator :math:`U(s) = exp(-iH(s)\Delta t)` with Hamiltonian

.. math:: H(s) = (1-s) H_{init} + (s) H_{final} = H_{init} (1- k/M) + H_{final} (k/M)

where :math:`M` is the number of interpolating steps and :math:`k = 0, 1, ... M` **[10]**, **[11]**. Provided the interpolation between :math:`H_{initial}` and :math:`H_{final}` is slow,
the adiabatic principle states the system remains in an energy eigenstate of :math:`H(s)` at all times. So, the state of the system following interpolation is
the ground state of :math:`H_{final}`. The total evolution time :math:`t = M\Delta t` must satisfy :math:`t >> 1/(E_0-E_1)^2` where :math:`E_0-E_1` is
the smallest difference between the first excited state and the ground state of :math:`H` for any :math:`s` **[10]**.

This approach has been previously applied to simulate the ground state of Fermi-Hubbard model with chemical potential and magnetic
field terms, starting from the ground state of a Hamiltonian that describes d-wave electron pairing (a type of superconductivity) **[12]**. 
The adiabatic_fermi_hubbard package uses a different starting point to find the ground state of the Fermi-Hubbard model through adiabatic state preparation
for small lattices.

Implementation
--------------
This package creates Qiskit circuits **[12]** to carry out adiabatic state preparation to find the ground state energy of the Fermi-Hubbard Hamiltonian. The following
section highlights some details of the implementation.

Jordan-Wigner Transformation
''''''''''''''''''''''''''''
One mapping which takes the fermionic raising/lowering operators in the Fermi-Hubbard Hamiltonian to operations which can be run on a spin-based qubit system is the
Jordan-Wigner transformation. The transformation is given by

.. math:: a_{i \sigma}

Trotterization
''''''''''''''
Following the Jordan-Wigner transformation, the Fermi-Hubbard Hamiltonian becomes a sum of Pauli strings, each of which has an associated
coefficient. Symbolically,

.. math:: H_{after JW} = \sum_{j}^{K} \alpha_j P_j

where :math:`\alpha_i` are the coefficients and :math:`P_i` are Pauli strings of length :math:`2N`, where :math:`N` is the number of lattice sites.
Generally, not all of the Pauli strings in :math:`H_{after JW}` commute, meaning

.. math:: exp(-i \Delta t \sum_{j} \alpha_j P_j ) \neq exp(-i \Delta t \alpha_1 P_1) exp(-i \Delta t \alpha_2 P_2) ... exp(-i \Delta t \alpha_K P_K)

However, provided :math:`\Delta t` is small, the Trotter approximation allows

.. math:: exp(-i \Delta t \sum_{j} \alpha_j P_j ) \approx exp(-i \Delta t \alpha_1 P_1) exp(-i \Delta t \alpha_2 P_2) ... exp(-i \Delta t \alpha_K P_K)

The adiabatic_fermi_hubbard package assumes the Trotter approximation to decompose the Jordan-Wigner transformed Hamiltonian into a sequence
of rotations about Pauli strings.

Rotation about N-dimensional Pauli strings
''''''''''''''''''''''''''''''''''''''''''
Once an evolution operator of the form :math:`exp(-i \Delta t  \sum_{j}^{K} \alpha_j P_j)`` is decomposed using the 
Trotter approximation, it becomes necessary to implement rotations about arbitrary Pauli strings of length :math:`2N`. 
To accomplish this, the package utilizes the approach discussed in Nielsen and Chuang, Ch 4 **[14]**. The strategy is briefly summarized here.

A rotation about an arbitrary Pauli string can be turned into a single qubit rotation by mapping the parity of each qubit onto an
ancilla qubit (or onto the last qubit involved in the rotation) using :math:`CNOT` gates and then performing a :math:`Z`-rotation on that qubit. Following said 
rotation, :math:`CNOT` s are required to "uncompute" the parity. For instance, a circuit which performs the rotation :math:`exp(-i \pi (ZZZZ))` is given by

.. image:: ./zzzz.png
 :width: 400

If the Pauli string contains :math:`X` or :math:`Y` gates, they can be transformed into :math:`Z` gates for the purpose of the parity encoding by applying a 
:math:`H` gate or a :math:`R_Y(3\pi/2)` gate before the CNOTs, respectively. The inverse operations are required after the second set of :math:`CNOT` s. For example,
a circuit which perofrms the rotation :math:`exp(-i \ pi (ZXYZ))` is

.. image:: ./zxyz.png
 :width: 400

Additional details can be found in **[14]**.

Validation
''''''''''



Examples
--------

Initializing a HubbardHamiltonian object for a 4 site lattice
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
This example shows how to create instances of the Lattice and HubbardHamiltonian classes.

::

    import adiabatic_fermi_hubbard as afh 
    lattice1 = afh.Lattice(4, bc=0) # no periodic boundary conditions

    # create HubbardHamiltonian with t = 2, U = 4, mu = -2
    hamiltonian1 = afh.HubbardHamiltonian(lattice1, t=2, U=4, mu=-2)

    print(hamiltonian1)

This should produce the following output:

::

    t = 2
    U = 4
    mu = -2

    Lattice:
    Number of sites: 4 sites, 
    Periodic boundary conditions: False.

    Fermionic Operator
    number spin orbitals=8, number terms=24
    -2.0 * ( +_0 -_2 )
    + 2.0 * ( -_0 +_2 )
    + -2.0 * ( +_2 -_4 )
    + 2.0 * ( -_2 +_4 )
    + -2.0 * ( +_4 -_6 )
    + 2.0 * ( -_4 +_6 )
    + 2.0 * ( -_1 +_3 )
    + -2.0 * ( +_1 -_3 )
    + -2.0 * ( +_3 -_5 )
    + 2.0 * ( -_3 +_5 )
    + 2.0 * ( -_5 +_7 )
    + -2.0 * ( +_5 -_7 )
    + 4.0 * ( +_4 -_4 +_5 -_5 )
    + 4.0 * ( +_6 -_6 +_7 -_7 )
    + 4.0 * ( +_0 -_0 +_1 -_1 )
    ...
    + -2.0 * ( +_1 -_1 )
    + -2.0 * ( +_2 -_2 )
    + -2.0 * ( +_5 -_5 )
    + -2.0 * ( +_7 -_7 )

Rotating about a Pauli string
'''''''''''''''''''''''''''''
This example demonstrates the functionality of the AdiabaticCircuit method pauli_string_rotation.

::
    
    import adiabatic_fermi_hubbard as afh
    import numpy as np
    import matplotlib as mpl
    from qiskit.quantum_info import SparsePauliOp

    lattice1 = afh.Lattice(2, bc=0) # 2 sites = 4 qubits, no periodic boundary conditions

    # create HubbardHamiltonian with t = 2, U = 4, \mu = -2
    hamiltonian1 = afh.HubbardHamiltonian(lattice1, t=2, U=4, mu=-2)

    # create AdiabaticCircuit object
    ad_circ1 = afh.AdiabaticCircuit(hamiltonian1)

    operators = SparsePauliOp(["ZYXI", "ZZII"], coeffs=[1,1])
    # rotation about ZYXI (rightmost gate acts on qubit 0)

    circ1 = ad_circ1.pauli_string_rotation(operators.paulis[0], np.pi)

    # rotation about ZZII (rightmost gate acts on qubit 0)
    circ2 = ad_circ1.pauli_string_rotation(operators.paulis[1], np.pi)

    circ2.draw(output = "mpl")

This should produce the following two circuits:

.. image:: ./zyxi.png
 :width: 400


.. image:: ./zzii.png
 :width: 400


Building and running an adiabatic state preparation circuit for N = 2 lattice sites
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
This example shows how to create and execute a circuit to find the ground state energy of a Fermi-Hubbard Hamiltonian through
adiabatic state preparation.

::

    import adiabatic_fermi_hubbard as afh

    lattice1 = afh.Lattice(2, bc=0) # no periodic boundary conditions

    # create HubbardHamiltonian with t = 2, U = 10, \mu = -5
    hamiltonian1 = afh.HubbardHamiltonian(lattice1, t=2, U=10, mu=-5)

    # create AdiabaticCircuit with time_step = 0.01, step_count = 20000
    ad_circ1 = afh.AdiabaticCircuit(hamiltonian1, time_step = 0.01, step_count = 20000)

    circ = ad_circ1.create_circuit()
    result = ad_circ1.run(circ)
    energy = ad_circ.calc_energy(result)

    print("Ground state energy: " + str(energy))
    
This should result in the following output:

::

    Ground state energy: 

Using qiskit-nature's eigensolver
'''''''''''''''''''''''''''''''''
This example illustrates the methods in the AdiabaticCircuit class which can be used for validating
the ground state energy resulting from adiabatic state preparation.

::

    import adiabatic_fermi_hubbard as afh

    lattice1 = afh.Lattice(2, bc=0) # no periodic boundary conditions

    # create HubbardHamiltonian with t = 2, U = 10, \mu = -5
    hamiltonian1 = afh.HubbardHamiltonian(lattice1, t=2, U=10, mu=-5)

    # create AdiabaticCircuit with time_step = 0.01, step_count = 20000
    ad_circ1 = afh.AdiabaticCircuit(hamiltonian1, time_step = 0.01, step_count = 20000)

    comparison_energy = ad_circ1.run_eigensolver_comparison()

    print("Ground state energy from eigensolver: " + str(comparison_energy))

This result in the following output:

::

    Ground state energy (eigensolver): 

Error as a function of step count / step length
'''''''''''''''''''''''''''''''''''''''''''''''



References
----------
**[1]** Qin, M., T. Schäfer, S. Andergassen, P. Corboz, and E. Gull, 2022, Annu. Rev. Condens. Matter Phys., 13, 275-302, DOI: https://doi.org/10.1146/annurev-conmatphys-090921-033948.

**[2]** Jiang, Z., K. J. Sung, K. Kechedzhi, V. N. Smelyanskiy, and S. Boixo, 2018, Phys. Rev. Applied, 9, 044036, DOI: https://doi.org/10.1103/PhysRevApplied.9.044036. 

**[3]** Hofstetter, W. and T. Qin, 2018, J. Phys. B: At. Mol. Opt. Phys., 51, 082001, DOI: https://doi.org/10.1088/1361-6455/aaa31b.

**[4]** Li, Z-X. and H. Yao, 2019, Annu. Rev. Condens. Matter Phys., 10, 337-56, DOI: https://doi.org/10.1146/annurev-conmatphys-033117-054307.

**[5]** Arovas, D. P., E. Berg, S. A. Kivelson, and S. Raghu, Annu. Rev. Condens. Matter Phys., 13, 239-74, DOI: https://doi.org/10.1146/annurev-conmatphys-031620-102024. 

**[6]** Zhang, J. M., and R. X. Dong, 2010, Eur. J. Phys., 31, 591, DOI: https://doi.org/10.1088/0143-0807/31/3/016.

**[7]** Lin, H. Q., 1990, 42, 6561, DOI: https://doi.org/10.1103/PhysRevB.42.6561.  

**[8]** Lin, H. Q., J. E. Gubernatis, H. Gould, and J. Tobochnik, 1993, Comput. Phys. 7, 400-07, DOI: https://doi.org/10.1063/1.4823192.

**[9]** Stanisic, S., J. L. Bosse, F. M. Gambetta, R. A. Santos, W. Mruczkiewicz, T. E. O’Brien, E. Ostby, and A. Montanaro, 2022, Nat. Commun., 13, 5743, DOI: https://doi.org/10.1038/s41467-022-33335-4.

**[10]** Albash, T. and D. A. Lidar, 2018, Rev. Mod. Phys., 90, 015002, DOI: https://doi.org/10.1103/RevModPhys.90.015002.

**[11]** Mayhall, N. Adiabatic Evolution of Ising Hamiltonian with Quantum Circuit. https://github.com/CHEM-PHYS-X684/AdiabaticPrinciple/blob/main/3_adiabatic.ipynb. 

**[12]** Qiskit contributors. Qiskit: An Open-source Framework for Quantum Computing, 2023, DOI: https://doi.org/10.5281/zenodo.2573505. 

**[14]**